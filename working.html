<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delhi NCR 3D Flood - Zero Lag Rendering</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        #map { width: 100vw; height: 100vh; }

        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 12px;
        }
        #legend h3 { margin: 0 0 12px 0; font-size: 16px; color: #1e40af; }
        .legend-item { display: flex; align-items: center; margin: 6px 0; }
        .legend-color { width: 30px; height: 16px; margin-right: 10px; border-radius: 3px; }
        #cacheInfo { margin-top: 10px; padding: 8px; background: #f0f9ff; border-radius: 6px; font-size: 10px; color: #0369a1; line-height: 1.5; }

        #timelineControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 550px;
        }
        #timelineControls h3 { margin: 0 0 10px 0; text-align: center; font-size: 14px; color: #1e40af; }
        #timeDisplay { text-align: center; font-size: 18px; font-weight: bold; color: #dc2626; margin-bottom: 10px; }
        #timeSlider { width: 100%; height: 8px; margin: 10px 0; border-radius: 4px; -webkit-appearance: none; appearance: none; background: linear-gradient(to right, #3b82f6, #1e40af); cursor: pointer; }
        #timeSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #dc2626; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        #timeSlider::-moz-range-thumb { width: 20px; height: 20px; background: #dc2626; border-radius: 50%; border: none; cursor: pointer; }

        #sliderButtons { display: flex; gap: 8px; justify-content: center; margin-top: 12px; }
        #sliderButtons button { background: #3b82f6; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s; }
        #sliderButtons button:hover { background: #1e40af; transform: translateY(-2px); }

        .speed-control { text-align: center; margin-top: 10px; font-size: 11px; }
        .speed-control select { padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc; }

        #loadingStatus { text-align: center; margin-top: 8px; font-size: 10px; color: #059669; font-weight: 600; }

        #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; flex-direction: column; }
        #loadingOverlay.hidden { display: none; }
        .loader { text-align: center; color: white; }
        .spinner { border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div class="loader">
            <div class="spinner"></div>
            <h2 style="margin-top: 20px;">Initializing Flood Visualization...</h2>
            <p id="initialLoadStatus">Loading master geometry...</p>
            <p id="loadingProgress" style="font-size: 12px; margin-top: 10px;">0%</p>
        </div>
    </div>

    <div id="map"></div>

    <div id="legend">
        <h3>Flood Depth (m)</h3>
        <div class="legend-item"><div class="legend-color" style="background:#bbdefb;"></div><span>&lt; 0.5</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#42a5f5;"></div><span>0.5‚Äì1</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#1976d2;"></div><span>1‚Äì2</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#0d47a1;"></div><span>&gt; 2</span></div>
    </div>

    <div id="timelineControls">
        <div id="timeDisplay">Time: 00:00:00</div>
        <input type="range" id="timeSlider" min="0" max="336" value="0" step="1">
        <div id="sliderButtons">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="prevBtn">‚èÆÔ∏è Prev</button>
            <button id="nextBtn">‚è≠Ô∏è Next</button>
            <button id="resetBtn">üîÑ Reset</button>
        </div>
        <div class="speed-control">
            Speed: <select id="playSpeed">
                <option value="100">Very Fast</option>
                <option value="200">Fast</option>
                <option value="500" selected>Normal</option>
                <option value="1000">Slow</option>
                <option value="2000">Very Slow</option>
            </select>
        </div>
        <div id="loadingStatus">Ready</div>
    </div>

    <script>
        const API_KEY = '3vyFCdEjKRCq9JRv9kWH';
        maptilersdk.config.apiKey = API_KEY;

        let map, scene, camera, renderer;
        let modelTransform;
        let currentTimestep = 0;
        let totalTimesteps = 336;
        let isPlaying = false;
        let playInterval = null;
        let playSpeed = 500;
        let depthScale = 1.0;
        
        // Pre-created meshes (fixed geometry, reused across timesteps)
        let waterMeshes = []; // Array of { mesh, polygonIndex }
        let depthDataView = null; // Float32Array from binary
        let polygonCount = 0;
        let minDepthGlobal = Infinity;
        let maxDepthGlobal = -Infinity;

        const customLayer = {
            id: '3d-model', type: 'custom', renderingMode: '3d',
            onAdd(m, gl) {
                camera = new THREE.Camera();
                scene = new THREE.Scene();
                const light = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(light);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(100, 200, 100);
                scene.add(dirLight);
                renderer = new THREE.WebGLRenderer({ canvas: m.getCanvas(), context: gl, antialias: true });
                renderer.autoClear = false;
            },
            render(gl, matrix) {
                const rx = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1,0,0), modelTransform.rotateX);
                const ry = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,1,0), modelTransform.rotateY);
                const rz = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,0,1), modelTransform.rotateZ);
                const m = new THREE.Matrix4().fromArray(matrix);
                const l = new THREE.Matrix4()
                    .makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)
                    .scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))
                    .multiply(rx).multiply(ry).multiply(rz);
                camera.projectionMatrix = m.multiply(l);
                renderer.resetState();
                renderer.render(scene, camera);
                map.triggerRepaint();
            }
        };

        map = new maptilersdk.Map({
            container: 'map', style: maptilersdk.MapStyle.STREETS,
            center: [77.027, 28.448], zoom: 14, pitch: 60, bearing: -20
        });

        map.on('style.load', () => {
            const origin = [77.027, 28.448];
            const coord = maptilersdk.MercatorCoordinate.fromLngLat(origin, 0);
            modelTransform = {
                translateX: coord.x, translateY: coord.y, translateZ: coord.z,
                rotateX: Math.PI/2, rotateY: 0, rotateZ: 0,
                scale: coord.meterInMercatorCoordinateUnits()
            };
            map.addLayer(customLayer);
            initializeVisualization();
        });

        async function initializeVisualization() {
            try {
                // STEP 1: Load master GeoJSON
                document.getElementById('initialLoadStatus').textContent = 'Loading polygon geometry...';
                const res = await fetch('flood_depth_master_slim.geojson');
                if(!res.ok) throw new Error('Master file not found');
                const geojson = await res.json();
                
                polygonCount = geojson.features.length;
                console.log(`‚úÖ Master loaded: ${polygonCount} polygons`);
                document.getElementById('loadingProgress').textContent = '50% - Creating 3D geometry...';

                // STEP 2: Create all geometry once (takes time but only once)
                const startGeom = performance.now();
                createAllGeometry(geojson.features);
                const geomTime = ((performance.now() - startGeom) / 1000).toFixed(2);
                console.log(`‚úÖ Geometry created in ${geomTime}s`);
                
                // STEP 3: Load binary depth data
                document.getElementById('initialLoadStatus').textContent = 'Loading 337 timesteps binary data...';
                const binRes = await fetch('flood_depths.bin');
                if(!binRes.ok) throw new Error('Binary file not found');
                const buffer = await binRes.arrayBuffer();
                depthDataView = new Float32Array(buffer);
                console.log(`‚úÖ Binary loaded: ${depthDataView.length} values`);

                // Calculate global depth range
                for(let i = 0; i < depthDataView.length; i++) {
                    const d = depthDataView[i];
                    if(d > 0) {
                        minDepthGlobal = Math.min(minDepthGlobal, d);
                        maxDepthGlobal = Math.max(maxDepthGlobal, d);
                    }
                }
                console.log(`Depth range: ${minDepthGlobal.toFixed(3)} - ${maxDepthGlobal.toFixed(3)}m`);

                document.getElementById('loadingProgress').textContent = '100% - Ready!';
                
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    document.getElementById('cacheInfo').style.display = 'block';
                    updateTimestep(0);
                }, 500);
                
            } catch(err) {
                console.error('‚ùå Error:', err);
                document.getElementById('initialLoadStatus').textContent = `Error: ${err.message}`;
            }
        }

        function createAllGeometry(features) {
            if(!scene) return;

            // Create mesh for each polygon once
            features.forEach((feature, idx) => {
                const coords = feature.geometry.coordinates[0];
                if(coords.length < 3) return;

                const pts = coords.map(c=>{
                    const [lng, lat] = c;
                    const m = maptilersdk.MercatorCoordinate.fromLngLat([lng,lat]);
                    return new THREE.Vector2((m.x-modelTransform.translateX)/modelTransform.scale, (m.y-modelTransform.translateY)/modelTransform.scale);
                });

                if(pts.length < 3) return;

                try {
                    const shape = new THREE.Shape(pts);
                    const geo = new THREE.ExtrudeGeometry(shape, {depth: 1, bevelEnabled: false}); // depth=1, will scale by depth value
                    geo.rotateX(-Math.PI/2);

                    // Create material (color will be updated per timestep)
                    const mat = new THREE.MeshPhongMaterial({ 
                        color: 0x42a5f5,
                        transparent: true, 
                        opacity: 0.85,
                        side: THREE.DoubleSide 
                    });

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.polygonIndex = idx; // Store for lookup
                    scene.add(mesh);
                    waterMeshes.push(mesh);

                    if(idx % 10000 === 0) {
                        document.getElementById('loadingProgress').textContent = `Creating geometry: ${Math.round(idx/polygonCount*50)}%`;
                    }

                } catch(e) {
                    console.error(`Polygon ${idx}:`, e);
                }
            });

            console.log(`Created ${waterMeshes.length} meshes`);
        }

        function updateTimestep(step) {
            if(!depthDataView || waterMeshes.length === 0) return;

            const startTime = performance.now();

            // Update each mesh's color and scale based on depth at this timestep
            waterMeshes.forEach(mesh => {
                const idx = mesh.polygonIndex;
                const depth = depthDataView[step * polygonCount + idx];

                if(depth > 0) {
                    // Update scale (height of extrusion)
                    mesh.scale.y = depth * depthScale;
                    mesh.visible = true;

                    // Update color based on depth
                    let color;
                    if(depth < 0.5) color = 0xbbdefb;
                    else if(depth < 1.0) color = 0x42a5f5;
                    else if(depth < 2.0) color = 0x1976d2;
                    else color = 0x0d47a1;

                    mesh.material.color.setHex(color);
                } else {
                    mesh.visible = false;
                }
            });

            const renderTime = performance.now() - startTime;
            console.log(`Step ${step}: ${renderTime.toFixed(2)}ms`);
            currentTimestep = step;
            updateDisplay();
        }

        function updateDisplay() {
            const baseDate = new Date('2025-07-13T01:55:00');
            const totalMinutes = currentTimestep * 5;
            const d = new Date(baseDate);
            d.setMinutes(d.getMinutes() + totalMinutes);
            
            const dateStr = d.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' });
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            const seconds = String(d.getSeconds()).padStart(2, '0');
            const timeStr = `${hours}:${minutes}:${seconds}`;
            
            document.getElementById('timeDisplay').textContent = `${dateStr} - ${timeStr}`;
            document.getElementById('timeSlider').value = currentTimestep;
        }

        document.getElementById('timeSlider').addEventListener('input', e => {
            const newStep = parseInt(e.target.value);
            updateTimestep(newStep);
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            if(isPlaying) {
                playInterval = setInterval(() => {
                    const nextStep = currentTimestep >= totalTimesteps ? 0 : currentTimestep + 1;
                    updateTimestep(nextStep);
                }, playSpeed);
            } else {
                clearInterval(playInterval);
            }
        });

        document.getElementById('prevBtn').addEventListener('click', () => {
            if(currentTimestep > 0) updateTimestep(currentTimestep - 1);
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if(currentTimestep < totalTimesteps) updateTimestep(currentTimestep + 1);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if(isPlaying) document.getElementById('playBtn').click();
            updateTimestep(0);
        });

        document.getElementById('playSpeed').addEventListener('change', e => {
            playSpeed = parseInt(e.target.value);
            if(isPlaying) {
                clearInterval(playInterval);
                document.getElementById('playBtn').click();
            }
        });
    </script>
</body>
</html>
