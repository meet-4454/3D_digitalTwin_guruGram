<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flood Twin</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        #map { width: 100vw; height: 100vh; }

        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 12px;
        }
        #legend h3 { margin: 0 0 12px 0; font-size: 16px; color: #1e40af; }
        .legend-item { display: flex; align-items: center; margin: 6px 0; }
        .legend-color { width: 30px; height: 16px; margin-right: 10px; border-radius: 3px; }
        #cacheInfo { margin-top: 10px; padding: 8px; background: #f0f9ff; border-radius: 6px; font-size: 10px; color: #0369a1; line-height: 1.5; }

        #timelineControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 550px;
        }
        #timelineControls h3 { margin: 0 0 10px 0; text-align: center; font-size: 14px; color: #1e40af; }
        #timeDisplay { text-align: center; font-size: 18px; font-weight: bold; color: #dc2626; margin-bottom: 10px; }
        #timeSlider { width: 100%; height: 8px; margin: 10px 0; border-radius: 4px; -webkit-appearance: none; appearance: none; background: linear-gradient(to right, #3b82f6, #1e40af); cursor: pointer; }
        #timeSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #dc2626; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        #timeSlider::-moz-range-thumb { width: 20px; height: 20px; background: #dc2626; border-radius: 50%; border: none; cursor: pointer; }

        #sliderButtons { display: flex; gap: 8px; justify-content: center; margin-top: 12px; }
        #sliderButtons button { background: #3b82f6; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; }
        #sliderButtons button:hover { background: #1e40af; }

        .speed-control { text-align: center; margin-top: 10px; font-size: 11px; }
        .speed-control select { padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc; }

        #loadingStatus { text-align: center; margin-top: 8px; font-size: 10px; color: #059669; font-weight: 600; }

        #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; flex-direction: column; }
        #loadingOverlay.hidden { display: none; }
        .loader { text-align: center; color: white; }
        .spinner { border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div class="loader">
            <div class="spinner"></div>
            <h2 style="margin-top: 20px;">Initializing Flood Visualization...</h2>
            <p id="initialLoadStatus">Loading coordinates...</p>
            <p id="loadingProgress" style="font-size: 12px; margin-top: 10px;">0%</p>
        </div>
    </div>

    <div id="map"></div>

    <div id="legend">
        <h3>Flood Depth (m)</h3>
        <div class="legend-item"><div class="legend-color" style="background:#bbdefb;"></div><span>&lt; 0.5</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#42a5f5;"></div><span>0.5‚Äì1</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#1976d2;"></div><span>1‚Äì2</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#0d47a1;"></div><span>&gt; 2</span></div>
    </div>

    <div id="timelineControls">
        <div id="timeDisplay">Time: 00:00:00</div>
        <input type="range" id="timeSlider" min="0" max="336" value="0" step="1">
        <div id="sliderButtons">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="prevBtn">‚èÆÔ∏è Prev</button>
            <button id="nextBtn">‚è≠Ô∏è Next</button>
            <button id="resetBtn">üîÑ Reset</button>
        </div>
        <div class="speed-control">
            Speed: <select id="playSpeed">
                <option value="100">Very Fast</option>
                <option value="200">Fast</option>
                <option value="500" selected>Normal</option>
                <option value="1000">Slow</option>
                <option value="2000">Very Slow</option>
            </select>
        </div>
        <div id="loadingStatus">Ready</div>
    </div>

    <script>
        const API_KEY = '3vyFCdEjKRCq9JRv9kWH';
        maptilersdk.config.apiKey = API_KEY;

        let map, scene, camera, renderer;
        let modelTransform;
        let currentTimestep = 0;
        let totalTimesteps = 336;
        let isPlaying = false;
        let playInterval = null;
        let playSpeed = 500;
        let depthScale = 1.0;
        
        // Single merged geometry (all polygons in one buffer)
        let mergedGeometry = null;
        let mergedMesh = null;
        let polygonIndex = null;
        let currentChunkData = null;
        let currentChunkIndex = -1;
        let polygonCount = 0;
        
        const CHUNK_SIZE = 10;
        const TOTAL_CHUNKS = 34;

        const customLayer = {
            id: '3d-model', type: 'custom', renderingMode: '3d',
            onAdd(m, gl) {
                camera = new THREE.Camera();
                scene = new THREE.Scene();
                const light = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(light);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(100, 200, 100);
                scene.add(dirLight);
                renderer = new THREE.WebGLRenderer({ canvas: m.getCanvas(), context: gl, antialias: true });
                renderer.autoClear = false;
            },
            render(gl, matrix) {
                const rx = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1,0,0), modelTransform.rotateX);
                const ry = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,1,0), modelTransform.rotateY);
                const rz = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,0,1), modelTransform.rotateZ);
                const m = new THREE.Matrix4().fromArray(matrix);
                const l = new THREE.Matrix4()
                    .makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)
                    .scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))
                    .multiply(rx).multiply(ry).multiply(rz);
                camera.projectionMatrix = m.multiply(l);
                renderer.resetState();
                renderer.render(scene, camera);
                map.triggerRepaint();
            }
        };

        map = new maptilersdk.Map({
            container: 'map', style: maptilersdk.MapStyle.STREETS,
            center: [77.027, 28.448], zoom: 14, pitch: 60, bearing: -20
        });

        map.on('style.load', () => {
            const origin = [77.027, 28.448];
            const coord = maptilersdk.MercatorCoordinate.fromLngLat(origin, 0);
            modelTransform = {
                translateX: coord.x, translateY: coord.y, translateZ: coord.z,
                rotateX: Math.PI/2, rotateY: 0, rotateZ: 0,
                scale: coord.meterInMercatorCoordinateUnits()
            };
            map.addLayer(customLayer);
            initializeVisualization();
        });

        async function initializeVisualization() {
            try {
                document.getElementById('initialLoadStatus').textContent = 'Loading polygon index...';
                
                // Load polygon index (metadata)
                const indexRes = await fetch('polygon_index.json');
                if(!indexRes.ok) throw new Error('Index file not found');
                polygonIndex = await indexRes.json();
                polygonCount = polygonIndex.length;
                
                console.log(`‚úÖ Index loaded: ${polygonCount} polygons`);
                document.getElementById('loadingProgress').textContent = '25% - Loading coordinates...';

                // Load binary coordinates
                const coordRes = await fetch('coordinates.bin');
                if(!coordRes.ok) throw new Error('Coordinates file not found');
                const coordBuffer = await coordRes.arrayBuffer();
                
                console.log(`‚úÖ Coordinates loaded: ${(coordBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
                document.getElementById('loadingProgress').textContent = '50% - Building geometry...';

                // Create merged geometry from binary coordinates
                await createMergedGeometry(coordBuffer);
                
                console.log(`‚úÖ Merged geometry created`);
                document.getElementById('loadingProgress').textContent = '75% - Loading first chunk...';

                // Load first chunk
                await loadChunk(0);
                
                document.getElementById('loadingProgress').textContent = '100% - Ready!';
                
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    document.getElementById('cacheInfo').style.display = 'block';
                    updateTimestep(0);
                }, 500);
                
            } catch(err) {
                console.error('Error:', err);
                document.getElementById('initialLoadStatus').textContent = `Error: ${err.message}`;
            }
        }

        async function createMergedGeometry(coordBuffer) {
            const view = new DataView(coordBuffer);
            let offset = 0;

            const vertices = [];
            const indices = [];
            let vertexCount = 0;
            const polygonVertexMap = []; // Map polygon index to vertex indices

            for(let p = 0; p < polygonCount; p++) {
                const pointCount = view.getUint32(offset, true);
                offset += 4;

                // First pass: read all coordinates
                const coords = [];
                const tempOffset = offset;
                for(let i = 0; i < pointCount; i++) {
                    const lng = view.getFloat64(offset, true);
                    offset += 8;
                    const lat = view.getFloat64(offset, true);
                    offset += 8;
                    coords.push({lng, lat});
                }

                const polygonVertices = [];
                const topVertices = [];

                // Create vertices from coordinates
                for(let i = 0; i < coords.length; i++) {
                    const {lng, lat} = coords[i];

                    const m = maptilersdk.MercatorCoordinate.fromLngLat([lng, lat]);
                    const x = (m.x - modelTransform.translateX) / modelTransform.scale;
                    const y = (m.y - modelTransform.translateY) / modelTransform.scale;

                    // Bottom face (z=0)
                    vertices.push(x, 0, y);
                    polygonVertices.push(vertexCount);
                    vertexCount++;

                    // Top face (will be scaled by depth)
                    vertices.push(x, depthScale, y);
                    topVertices.push(vertexCount);
                    vertexCount++;
                }

                polygonVertexMap.push({
                    bottom: polygonVertices,
                    top: topVertices,
                    count: pointCount
                });

                // Bottom face triangulation
                if(polygonVertices.length >= 3) {
                    for(let i = 1; i < polygonVertices.length - 1; i++) {
                        indices.push(polygonVertices[0], polygonVertices[i], polygonVertices[i+1]);
                    }
                }

                // Top face triangulation (reverse winding)
                if(topVertices.length >= 3) {
                    for(let i = 1; i < topVertices.length - 1; i++) {
                        indices.push(topVertices[0], topVertices[i+1], topVertices[i]);
                    }
                }

                // Side faces
                for(let i = 0; i < pointCount; i++) {
                    const j = (i + 1) % pointCount;
                    indices.push(
                        polygonVertices[i], polygonVertices[j], topVertices[i],
                        polygonVertices[j], topVertices[j], topVertices[i]
                    );
                }

                if(p % 5000 === 0) {
                    document.getElementById('loadingProgress').textContent = `Building: ${Math.round(p/polygonCount*25 + 50)}%`;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({ 
                color: 0x42a5f5,
                transparent: true, 
                opacity: 0.85,
                side: THREE.DoubleSide,
                vertexColors: true
            });

            mergedGeometry = geometry;
            mergedMesh = new THREE.Mesh(geometry, material);
            mergedMesh.visible = false; // Hide all polygons initially
            
            // Store vertex map for height updates
            mergedMesh.polygonVertexMap = polygonVertexMap;
            scene.add(mergedMesh);

            console.log(`Merged mesh: ${vertexCount} vertices, ${indices.length / 3} triangles`);
        }

        async function loadChunk(chunkIndex) {
            if(chunkIndex === currentChunkIndex) return;
            
            console.log(`Loading chunk ${chunkIndex}/${TOTAL_CHUNKS-1}`);

            try {
                const chunkFile = `chunk_${String(chunkIndex).padStart(3, '0')}.bin`;
                const res = await fetch(chunkFile);
                if(!res.ok) throw new Error(`Chunk ${chunkIndex} not found`);
                
                const buffer = await res.arrayBuffer();
                const view = new Float32Array(buffer);
                
                currentChunkData = {};
                const startTs = chunkIndex * CHUNK_SIZE;
                const endTs = Math.min(startTs + CHUNK_SIZE, 337);
                
                let idx = 0;
                for(let ts = startTs; ts < endTs; ts++) {
                    currentChunkData[ts] = view.slice(idx * polygonCount, (idx + 1) * polygonCount);
                    idx++;
                }
                
                currentChunkIndex = chunkIndex;
                console.log(`‚úÖ Chunk loaded: ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
                
            } catch(err) {
                console.error('Chunk error:', err);
            }
        }

        function updateTimestep(step) {
            if(!currentChunkData || !mergedMesh) return;

            const chunkIdx = Math.floor(step / CHUNK_SIZE);
            if(chunkIdx !== currentChunkIndex) {
                loadChunk(chunkIdx);
                return;
            }

            const depths = currentChunkData[step];
            if(!depths) return;

            // Make visible on first render
            if(!mergedMesh.visible) {
                mergedMesh.visible = true;
            }

            // Update vertex heights and colors
            const positions = mergedGeometry.attributes.position;
            const posArray = positions.array;
            const colors = new Float32Array(positions.count * 3);
            let colorIdx = 0;

            const polygonVertexMap = mergedMesh.polygonVertexMap;

            for(let p = 0; p < polygonCount; p++) {
                const depth = depths[p];
                let r, g, b;

                if(depth <= 0) {
                    r = g = b = 1; // White for no flood
                } else if(depth < 0.5) {
                    r = 0.73; g = 0.87; b = 0.98; // Light blue
                } else if(depth < 1.0) {
                    r = 0.26; g = 0.65; b = 0.96; // Blue
                } else if(depth < 2.0) {
                    r = 0.10; g = 0.46; b = 0.82; // Dark blue
                } else {
                    r = 0.05; g = 0.28; b = 0.63; // Very dark blue
                }

                const polyData = polygonVertexMap[p];
                
                // Update bottom vertices (stay at z=0)
                for(let idx of polyData.bottom) {
                    colors[idx * 3] = r;
                    colors[idx * 3 + 1] = g;
                    colors[idx * 3 + 2] = b;
                }

                // Update top vertices (scale height by depth)
                for(let idx of polyData.top) {
                    const vertexIdx = idx * 3;
                    posArray[vertexIdx + 1] = Math.max(depth * depthScale, 0.1); // Y is height
                    colors[vertexIdx] = r;
                    colors[vertexIdx + 1] = g;
                    colors[vertexIdx + 2] = b;
                }
            }

            positions.needsUpdate = true;
            mergedGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            mergedMesh.material.vertexColors = true;

            currentTimestep = step;
            updateDisplay();
        }

        function updateDisplay() {
            const baseDate = new Date('2025-07-10T01:55:00');
            const d = new Date(baseDate);
            d.setMinutes(d.getMinutes() + currentTimestep * 5);
            
            const dateStr = d.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' });
            const timeStr = d.toLocaleTimeString('en-US', { hour12: false });
            
            document.getElementById('timeDisplay').textContent = `${dateStr} - ${timeStr}`;
            document.getElementById('timeSlider').value = currentTimestep;
            document.getElementById('cacheInfo').innerHTML = 
                `<div>Step: ${currentTimestep}/336</div>
                 <div style="margin-top: 5px; font-size: 9px;">Chunk: ${currentChunkIndex} | ~20MB RAM</div>`;
        }

        document.getElementById('timeSlider').addEventListener('input', e => {
            const newStep = parseInt(e.target.value);
            updateTimestep(newStep);
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            if(isPlaying) {
                playInterval = setInterval(() => {
                    const nextStep = currentTimestep >= totalTimesteps ? 0 : currentTimestep + 1;
                    updateTimestep(nextStep);
                }, playSpeed);
            } else {
                clearInterval(playInterval);
            }
        });

        document.getElementById('prevBtn').addEventListener('click', () => {
            if(currentTimestep > 0) updateTimestep(currentTimestep - 1);
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if(currentTimestep < totalTimesteps) updateTimestep(currentTimestep + 1);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if(isPlaying) document.getElementById('playBtn').click();
            updateTimestep(0);
        });

        document.getElementById('playSpeed').addEventListener('change', e => {
            playSpeed = parseInt(e.target.value);
            if(isPlaying) {
                clearInterval(playInterval);
                document.getElementById('playBtn').click();
            }
        });
    </script>
</body>
</html>
